# 4. Expressing HTTP Semantics in HTTP/3 / 在 HTTP/3 中表达 HTTP 语义

## 4.1. HTTP Message Framing / HTTP 消息分帧

> A client sends an HTTP request on a [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams), which is a client-initiated bidirectional QUIC stream; see [Section 6.1](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams). A client **MUST** send only a single request on a given stream. A server sends zero or more interim HTTP responses on the same stream as the request, followed by a single final HTTP response, as detailed below. See [Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)] for a description of interim and final HTTP responses.

客户端在请求流上发送 HTTP 请求，请求流是客户端发起的双向 QUIC 流； 见第 6.1 节。 客户端**必须**在给定的流上只发送一个请求。 服务器在与请求相同的流上发送零个或多个临时 HTTP 响应，然后是单个最终 HTTP 响应，如下所述。 有关临时和最终 HTTP 响应的描述，请参见 [HTTP] 的第 15 节。

> Pushed responses are sent on a server-initiated unidirectional QUIC stream; see [Section 6.2.2](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams). A server sends zero or more interim HTTP responses, followed by a single final HTTP response, in the same manner as a standard response. Push is described in more detail in [Section 4.6](https://www.rfc-editor.org/rfc/rfc9114.html#server-push).

推送的响应在一个服务器发起的单向 QUIC 流上发送； 见第 6.2.2 节。 服务器以与标准响应相同的方式发送零个或多个临时 HTTP 响应，然后是单个最终 HTTP 响应。 推送在 4.6 节中有更详细的描述。

> On a given stream, receipt of multiple requests or receipt of an additional HTTP response following a final HTTP response **MUST** be treated as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

在一个给定的流上，收到多个请求或在最终 HTTP 响应之后收到额外的 HTTP 响应**必须**被视为格式错误。

> An HTTP message (request or response) consists of:
>
> 1. the header section, including message control data, sent as a single [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame,
> 2. optionally, the content, if present, sent as a series of [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames, and
> 3. optionally, the trailer section, if present, sent as a single [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame.
>
> Header and trailer sections are described in Sections [6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3) and [6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]; the content is described in [Section 6.4](https://www.rfc-editor.org/rfc/rfc9110#section-6.4) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)].

一个 HTTP 消息（请求或响应）包括：

1. 首部，包括消息控制数据，作为单个 HEADERS 帧发送，
2. 可选地，内容（如果存在）作为一系列 DATA 帧发送，以及
3. 可选地，尾部（如果存在）作为单个 HEADERS 帧发送。

Header 和 Trailer 部分在 [HTTP] 的 6.3 和 6.5 节中描述； 内容在 [HTTP] 的第 6.4 节中描述。

> Receipt of an invalid sequence of frames **MUST** be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_UNEXPECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_UNEXPECTED). In particular, a [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame before any [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame, or a [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) or [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame after the trailing [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame, is considered invalid. Other frame types, especially unknown frame types, might be permitted subject to their own rules; see [Section 9](https://www.rfc-editor.org/rfc/rfc9114.html#extensions).

接收到无效的帧序列**必须**被视为 H3_FRAME_UNEXPECTED 类型的连接错误。 特别的，任何 HEADERS 帧之前的 DATA 帧，或尾部 HEADERS 帧之后的 HEADERS 或 DATA 帧，都被认为是无效的。 其他帧类型，尤其是未知帧类型，可能会根据它们自己的规则被允许； 见第 9 节。

> A server **MAY** send one or more [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames before, after, or interleaved with the frames of a response message. These [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames are not part of the response; see [Section 4.6](https://www.rfc-editor.org/rfc/rfc9114.html#server-push) for more details. [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames are not permitted on [push streams](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams); a pushed response that includes [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames **MUST** be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_UNEXPECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_UNEXPECTED).

服务器**可能**在响应消息的帧之前、之后或与响应消息的帧交错发送一个或多个 PUSH_PROMISE 帧。 这些 PUSH_PROMISE 帧不是响应的一部分； 有关详细信息，请参阅第 4.6 节。 推送流上不允许使用 PUSH_PROMISE 帧； 包含 PUSH_PROMISE 帧的推送响应**必须**被视为 H3_FRAME_UNEXPECTED 类型的连接错误。

> Frames of unknown types ([Section 9](https://www.rfc-editor.org/rfc/rfc9114.html#extensions)), including reserved frames ([Section 7.2.8](https://www.rfc-editor.org/rfc/rfc9114.html#frame-reserved)) **MAY** be sent on a request or [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) before, after, or interleaved with other frames described in this section.

未知类型的帧（第 9 节），包括保留帧（第 7.2.8 节）**可能**在请求或推送流之前、之后或与本节中描述的其他帧中交错发送。

> The [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) and [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames might reference updates to the QPACK dynamic table. While these updates are not directly part of the message exchange, they must be received and processed before the message can be consumed. See [Section 4.2](https://www.rfc-editor.org/rfc/rfc9114.html#header-formatting) for more details.

HEADERS 和 PUSH_PROMISE 帧可能会引用对 QPACK 动态表的更新。 虽然这些更新不是消息交换的直接部分，但必须先接收和处理它们，然后才能消费消息。 有关详细信息，请参阅第 4.2 节。

> Transfer codings (see [Section 7](https://www.rfc-editor.org/rfc/rfc9112#section-7) of [[HTTP/1.1](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9112)]) are not defined for HTTP/3; the Transfer-Encoding header field **MUST NOT** be used.

没有为 HTTP/3 定义传输编码（参见 [HTTP/1.1] 的第 7 节）； **不得**使用 Transfer-Encoding 头域。

> A response **MAY** consist of multiple messages when and only when one or more interim responses (1xx; see [Section 15.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]) precede a final response to the same request. Interim responses do not contain content or trailer sections.

当且仅当一个或多个临时响应（1xx；参见 [HTTP] 的第 15.2 节）先于对同一请求的最终响应时，响应才**可能**包含多个消息。 临时响应不包含内容或尾部部分。

> An HTTP request/response exchange fully consumes a client-initiated bidirectional QUIC stream. After sending a request, a client **MUST** close the stream for sending. Unless using the CONNECT method (see [Section 4.4](https://www.rfc-editor.org/rfc/rfc9114.html#connect)), clients **MUST NOT** make stream closure dependent on receiving a response to their request. After sending a final response, the server **MUST** close the stream for sending. At this point, the QUIC stream is fully closed.

HTTP 请求/响应交换完全使用客户端发起的双向 QUIC 流。 发送请求后，客户端**必须**关闭要发送的流。 除非使用 CONNECT 方法（参见第 4.4 节），否则客户端**不得**依赖于接收到对其请求的响应来进行流关闭。 发送最终响应后，服务器**必须**关闭要发送的流。 此时，QUIC 流已完全关闭。

> When a stream is closed, this indicates the end of the final HTTP message. Because some messages are large or unbounded, endpoints **SHOULD** begin processing partial HTTP messages once enough of the message has been received to make progress. If a client-initiated stream terminates without enough of the HTTP message to provide a complete response, the server **SHOULD** abort its response stream with the error code [H3_REQUEST_INCOMPLETE](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_INCOMPLETE).

当一个流关闭时，这表示最终 HTTP 消息的结束。 由于某些消息很大或无界，端点**应该**在收到足够多的消息以取得进展后开始处理部分 HTTP 消息。 如果客户端发起的流在没有足够的 HTTP 消息来提供完整响应的情况下终止，则服务器**应该**使用错误代码 H3_REQUEST_INCOMPLETE 中止其响应流。

> A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When the server does not need to receive the remainder of the request, it **MAY** abort reading the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams), send a complete response, and cleanly close the sending part of the stream. The error code [H3_NO_ERROR](https://www.rfc-editor.org/rfc/rfc9114.html#H3_NO_ERROR) **SHOULD** be used when requesting that the client stop sending on the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams). Clients **MUST NOT** discard complete responses as a result of having their request terminated abruptly, though clients can always discard responses at their discretion for other reasons. If the server sends a partial or complete response but does not abort reading the request, clients **SHOULD** continue sending the content of the request and close the stream normally.

如果响应不依赖于尚未发送和接收的请求的任何部分，则服务器可以在客户端发送整个请求之前发送完整的响应。 当服务器不需要接收请求的剩余部分时，它**可以**中止读取请求流，发送完整的响应，并干净地关闭流的发送部分。 当请求客户端停止在请求流上发送时，应该使用错误代码 H3_NO_ERROR。 客户端**不能**因为他们的请求突然终止而丢弃完整的响应，尽管客户端总是可以出于其他原因自行决定丢弃响应。 如果服务器发送了部分或完整的响应但没有中止读取请求，客户端**应该**继续发送请求的内容并正常关闭流。

### 4.1.1. Request Cancellation and Rejection / 请求取消和拒绝

> Once a [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) has been opened, the request **MAY** be cancelled by either endpoint. Clients cancel requests if the response is no longer of interest; servers cancel requests if they are unable to or choose not to respond. When possible, it is **RECOMMENDED** that servers send an HTTP response with an appropriate status code rather than cancelling a request it has already begun processing.

一旦请求流被打开，请求**可以**被任一端点取消。 如果对响应不再感兴趣，客户会取消请求； 如果服务器无法响应或选择不响应，则服务器会取消请求。 如果可能，**建议**服务器发送带有适当状态代码的 HTTP 响应，而不是取消它已经开始处理的请求。

> Implementations **SHOULD** cancel requests by abruptly terminating any directions of a stream that are still open. To do so, an implementation resets the sending parts of streams and aborts reading on the receiving parts of streams; see [Section 2.4](https://www.rfc-editor.org/rfc/rfc9000#section-2.4) of [[QUIC-TRANSPORT](https://www.rfc-editor.org/rfc/rfc9114.html#QUIC-TRANSPORT)].

实现**应该**通过突然终止正开放流的任何方向来取消请求。 为此，实现会重置流的发送部分并中止对流的接收部分的读取； 参见 [QUIC-TRANSPORT] 的第 2.4 节。

> When the server cancels a request without performing any application processing, the request is considered "rejected". The server **SHOULD** abort its response stream with the error code [H3_REQUEST_REJECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_REJECTED). In this context, "processed" means that some data from the stream was passed to some higher layer of software that might have taken some action as a result. The client can treat requests rejected by the server as though they had never been sent at all, thereby allowing them to be retried later.

当服务器取消请求而不执行任何应用程序处理时，该请求被视为“拒绝”。 服务器**应该**使用错误代码 H3_REQUEST_REJECTED 中止其响应流。 在这种情况下，“已处理”意味着来自流的一些数据被传递到某些更高层的软件，这些软件可能因此采取了一些行动。 客户端可以将被服务器拒绝的请求视为根本没有发送过，从而允许稍后重试它们。

> Servers **MUST NOT** use the [H3_REQUEST_REJECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_REJECTED) error code for requests that were partially or fully processed. When a server abandons a response after partial processing, it **SHOULD** abort its response stream with the error code [H3_REQUEST_CANCELLED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_CANCELLED).

对于部分或全部处理的请求，服务器**不得**使用 H3_REQUEST_REJECTED 错误代码。 当服务器在部分处理后放弃响应时，它**应该**以错误代码 H3_REQUEST_CANCELLED 中止其响应流。

> Client **SHOULD** use the error code [H3_REQUEST_CANCELLED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_CANCELLED) to cancel requests. Upon receipt of this error code, a server **MAY** abruptly terminate the response using the error code [H3_REQUEST_REJECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_REJECTED) if no processing was performed. Clients **MUST NOT** use the [H3_REQUEST_REJECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_REJECTED) error code, except when a server has requested closure of the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) with this error code.

客户端**应该**使用错误代码 H3_REQUEST_CANCELLED 来取消请求。 收到此错误代码后，如果未执行任何处理，服务器**可能**会使用错误代码 H3_REQUEST_REJECTED 突然终止响应。 客户端**不得**使用 H3_REQUEST_REJECTED 错误代码，除非服务器使用此错误代码请求关闭请求流。

> If a stream is cancelled after receiving a complete response, the client **MAY** ignore the cancellation and use the response. However, if a stream is cancelled after receiving a partial response, the response **SHOULD NOT** be used. Only idempotent actions such as GET, PUT, or DELETE can be safely retried; a client **SHOULD NOT** automatically retry a request with a non-idempotent method unless it has some means to know that the request semantics are idempotent independent of the method or some means to detect that the original request was never applied. See [Section 9.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.2) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)] for more details.

如果在收到完整响应后取消流，客户端**可以**忽略取消并使用响应。 但是，如果在收到部分响应后取消流，则**不应该**使用响应。 只有 GET、PUT 或 DELETE 等幂等操作可以安全地重试； 客户端**不应该**使用非幂等方法自动重试请求，除非它有某种方法可以知道请求语义是独立于方法的幂等，或者有某种方法可以检测到原始请求从未被应用。 有关详细信息，请参阅 [HTTP] 的第 9.2.2 节。

### 4.1.2. Malformed Requests and Responses / 格式错误的请求和响应

> A malformed request or response is one that is an otherwise valid sequence of frames but is invalid due to:
>
> - the presence of prohibited fields or pseudo-header fields,
> - the absence of mandatory pseudo-header fields,
> - invalid values for pseudo-header fields,
> - pseudo-header fields after fields,
> - an invalid sequence of HTTP messages,
> - the inclusion of uppercase field names, or
> - the inclusion of invalid characters in field names or values.

格式错误的请求或响应是一个原本有效的帧序列，但由于以下原因而无效：

- 禁止字段或伪首部字段的存在，
- 缺失强制性的伪首部字段，
- 伪首部字段的无效值，
- 字段后的伪首部字段，
- 无效的 HTTP 消息序列，
- 包含大写字段名称，或
- 在字段名称或值中包含无效字符。

> A request or response that is defined as having content when it contains a Content-Length header field ([Section 8.6](https://www.rfc-editor.org/rfc/rfc9110#section-8.6) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]) is malformed if the value of the Content-Length header field does not equal the sum of the [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame lengths received. A response that is defined as never having content, even when a Content-Length is present, can have a non-zero Content-Length header field even though no content is included in [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames.

如果 Content-Length 首部字段的值不等于收到的 DATA 帧长度的总和，则将这个包含 Content-Length 首部字段（[HTTP] 的第 8.6 节）的请求或响应定义为格式不正确。被定义为从不包含内容的响应，即使存在 Content-Length，也可以具有非零的 Content-Length 首部字段，即使 DATA 帧中不包含任何内容。

> Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) **MUST NOT** forward a malformed request or response. Malformed requests or responses that are detected **MUST** be treated as a [stream error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_MESSAGE_ERROR](https://www.rfc-editor.org/rfc/rfc9114.html#H3_MESSAGE_ERROR).

处理 HTTP 请求或响应的中介（即任何不充当隧道的中介）**一定不能**转发格式错误的请求或响应。 检测到的格式错误的请求或响应**必须**被视为 H3_MESSAGE_ERROR 类型的流错误。

> For malformed requests, a server **MAY** send an HTTP response indicating the error prior to closing or resetting the stream. Clients **MUST NOT** accept a malformed response. Note that these requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.

对于格式错误的请求，服务器**可以**在关闭或重置流之前发送一个 HTTP 响应以指出错误。 客户端**不得**接受格式错误的响应。 请注意，这些要求旨在防止针对 HTTP 的几种常见攻击； 它们是故意严格的，因为对这些要求宽松可能会使实现暴露于这些漏洞。

## 4.2. HTTP Fields / HTTP 字段

> HTTP messages carry metadata as a series of key-value pairs called "HTTP fields"; see Sections [6.3](https://www.rfc-editor.org/rfc/rfc9110#section-6.3) and [6.5](https://www.rfc-editor.org/rfc/rfc9110#section-6.5) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. For a listing of registered HTTP fields, see the "Hypertext Transfer Protocol (HTTP) Field Name Registry" maintained at <https://www.iana.org/assignments/http-fields/>. Like HTTP/2, HTTP/3 has additional considerations related to the use of characters in field names, the Connection header field, and pseudo-header fields.

HTTP 消息携带元数据作为一系列称为“HTTP 字段”的键值对；请参阅 [HTTP] 的第 6.3 和 6.5 节。有关已注册 HTTP 字段的列表，请参阅 <https://www.iana.org/assignments/http-fields/> 维护的“超文本传输协议 (HTTP) 字段名称注册表”。与 HTTP/2 一样，HTTP/3 具有与在字段名称、连接首部字段和伪首部字段中使用字符相关的其他注意事项。

> Field names are strings containing a subset of ASCII characters. Properties of HTTP field names and values are discussed in more detail in [Section 5.1](https://www.rfc-editor.org/rfc/rfc9110#section-5.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. Characters in field names **MUST** be converted to lowercase prior to their encoding. A request or response containing uppercase characters in field names **MUST** be treated as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

字段名称是包含 ASCII 字符子集的字符串。 [HTTP] 的 5.1 节更详细地讨论了 HTTP 字段名称和值的属性。字段名称中的字符**必须**在编码之前转换为小写。字段名称中包含大写字符的请求或响应**必须**被视为格式错误。

> HTTP/3 does not use the Connection header field to indicate connection-specific fields; in this protocol, connection-specific metadata is conveyed by other means. An endpoint **MUST NOT** generate an HTTP/3 field section containing connection-specific fields; any message containing connection-specific fields **MUST** be treated as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

HTTP/3 不使用 Connection 头字段来指示特定于连接的字段；在此协议中，特定于连接的元数据通过其他方式传送。端点**不得**生成包含连接特定字段的 HTTP/3 字段部分；任何包含连接特定字段的消息都**必须**被视为格式错误。

> The only exception to this is the TE header field, which **MAY** be present in an HTTP/3 request header; when it is, it **MUST NOT** contain any value other than "trailers".

唯一的例外是 TE 标头字段，它**可能**出现在 HTTP/3 请求标头中；如果是，它**不能**包含除“trailers”之外的任何值。

> An intermediary transforming an HTTP/1.x message to HTTP/3 **MUST** remove connection-specific header fields as discussed in [Section 7.6.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)], or their messages will be treated by other HTTP/3 endpoints as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

将 HTTP/1.x 消息转换为 HTTP/3 的中介**必须**删除 [HTTP] 的第 7.6.1 节中讨论的特定于连接的头字段，否则它们的消息将被其他 HTTP/3 端点视为格式错误。

### 4.2.1. Field Compression / 字段压缩

> [[QPACK](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9204)] describes a variation of HPACK that gives an encoder some control over how much head-of-line blocking can be caused by compression. This allows an encoder to balance compression efficiency with latency. HTTP/3 uses QPACK to compress header and trailer sections, including the control data present in the header section.

[QPACK] 描述了 HPACK 的一种变体，它使编码器可以控制压缩导致的多少行头阻塞。 这允许编码器平衡压缩效率和延迟。 HTTP/3 使用 QPACK 来压缩首部和尾部部分，包括首部部分中的控制数据。

> To allow for better compression efficiency, the Cookie header field ([[COOKIES](https://www.rfc-editor.org/rfc/rfc9114.html#COOKIES)]) **MAY** be split into separate field lines, each with one or more cookie-pairs, before compression. If a decompressed field section contains multiple cookie field lines, these **MUST** be concatenated into a single byte string using the two-byte delimiter of "`; `" (ASCII 0x3b, 0x20) before being passed into a context other than HTTP/2 or HTTP/3, such as an HTTP/1.1 connection, or a generic HTTP server application.

为了提高压缩效率，在压缩之前，Cookie 标头字段 ([COOKIES]) **可以**拆分为单独的字段行，每行包含一个或多个 cookie 对。 如果解压缩的字段部分包含多个 cookie 字段行，则在传递到 HTTP/2 或 HTTP/ 3以外的上下文之前，**必须**使用“;”的两字节分隔符（ASCII 0x3b，0x20）将它们连接成一个单独的字节字符串，例如 HTTP/1.1 连接，或通用 HTTP 服务器应用程序。

### 4.2.2. Header Size Constraints / 首部尺寸限制

> An HTTP/3 implementation **MAY** impose a limit on the maximum size of the message header it will accept on an individual HTTP message. A server that receives a larger header section than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code ([[RFC6585](https://www.rfc-editor.org/rfc/rfc9114.html#RFC6585)]). A client can discard responses that it cannot process. The size of a field list is calculated based on the uncompressed size of fields, including the length of the name and value in bytes plus an overhead of 32 bytes for each field.

HTTP/3 实现**可以**对它将在单个 HTTP 消息上接受的消息首部的最大大小施加限制。接收到比它愿意处理的更大的标头部分的服务器可以发送 HTTP 431（请求标头字段太大）状态代码（[RFC6585]）。客户端可以丢弃它无法处理的响应。字段列表的大小是根据未压缩的字段大小计算的，包括名称和值的长度（以字节为单位）加上每个字段的 32 个字节的开销。

> If an implementation wishes to advise its peer of this limit, it can be conveyed as a number of bytes in the [SETTINGS_MAX_FIELD_SECTION_SIZE](https://www.rfc-editor.org/rfc/rfc9114.html#SETTINGS_MAX_FIELD_SECTION_SIZE) parameter. An implementation that has received this parameter **SHOULD NOT** send an HTTP message header that exceeds the indicated size, as the peer will likely refuse to process it. However, an HTTP message can traverse one or more intermediaries before reaching the origin server; see [Section 3.7](https://www.rfc-editor.org/rfc/rfc9110#section-3.7) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. Because this limit is applied separately by each implementation that processes the message, messages below this limit are not guaranteed to be accepted.

如果一个实现希望将此限制通知其对等方，则可以在 SETTINGS_MAX_FIELD_SECTION_SIZE 参数中将其作为字节数传送。接收到此参数的实现**不应该**发送超过指示大小的 HTTP 消息首部，因为对等方可能会拒绝处理它。但是，HTTP 消息在到达源服务器之前可以经过一个或多个中介；请参阅 [HTTP] 的第 3.7 节。因为这个限制是由处理消息的每个实现单独应用的，所以不能保证低于这个限制的消息被接受。

## 4.3. HTTP Control Data / HTTP 控制数据

> Like HTTP/2, HTTP/3 employs a series of pseudo-header fields, where the field name begins with the `:` character (ASCII 0x3a). These pseudo-header fields convey message control data; see [Section 6.2](https://www.rfc-editor.org/rfc/rfc9110#section-6.2) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)].

与 HTTP/2 一样，HTTP/3 使用一系列伪首部字段，其中字段名称以 : 字符（ASCII 0x3a）开头。这些伪首部传送消息控制数据；请参阅 [HTTP] 的第 6.2 节。

> Pseudo-header fields are not HTTP fields. Endpoints **MUST NOT** generate pseudo-header fields other than those defined in this document. However, an extension could negotiate a modification of this restriction; see [Section 9](https://www.rfc-editor.org/rfc/rfc9114.html#extensions).

伪首部字段不是 HTTP 字段。端点**不得**生成除本文档中定义的以外的伪首部字段。但是，扩展可以协商修改此限制；见第 9 节。

> Pseudo-header fields are only valid in the context in which they are defined. Pseudo-header fields defined for requests **MUST NOT** appear in responses; pseudo-header fields defined for responses **MUST NOT** appear in requests. Pseudo-header fields **MUST NOT** appear in trailer sections. Endpoints **MUST** treat a request or response that contains undefined or invalid pseudo-header fields as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

伪首部字段仅在定义它们的上下文中有效。为请求定义的伪首部字段**不得**出现在响应中；为响应定义的伪首部字段**不得**出现在请求中。伪首部字段**不得**出现在尾部中。端点**必须**将包含未定义或无效伪首部字段的请求或响应视为格式错误。

> All pseudo-header fields **MUST** appear in the header section before regular header fields. Any request or response that contains a pseudo-header field that appears in a header section after a regular header field **MUST** be treated as [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

所有伪首部字段**必须**出现在首部部分中的常规首部字段之前。任何包含出现在常规首部字段之后的首部部分中的伪首部字段的请求或响应，**必须**被视为格式错误。

### 4.3.1. Request Pseudo-Header Fields / 请求伪首部字段

> The following pseudo-header fields are defined for requests:
>
> - ":method":
>
>   Contains the HTTP method ([Section 9](https://www.rfc-editor.org/rfc/rfc9110#section-9) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)])
>
> - ":scheme":
>
>   Contains the scheme portion of the target URI ([Section 3.1](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) of [[URI](https://www.rfc-editor.org/rfc/rfc9114.html#URI)]).
>
>   The :scheme pseudo-header is not restricted to URIs with scheme "http" and "https". A proxy or gateway can translate requests for non-HTTP schemes, enabling the use of HTTP to interact with non-HTTP services.
>
>   See [Section 3.1.2](https://www.rfc-editor.org/rfc/rfc9114.html#other-schemes) for guidance on using a scheme other than "https".
>
> - ":authority":
>
>   Contains the authority portion of the target URI ([Section 3.2](https://www.rfc-editor.org/rfc/rfc3986#section-3.2) of [[URI](https://www.rfc-editor.org/rfc/rfc9114.html#URI)]). The authority **MUST NOT** include the deprecated userinfo subcomponent for URIs of scheme "http" or "https".
>
>   To ensure that the HTTP/1.1 request line can be reproduced accurately, this pseudo-header field **MUST** be omitted when translating from an HTTP/1.1 request that has a request target in a method-specific form; see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. Clients that generate HTTP/3 requests directly **SHOULD** use the :authority pseudo-header field instead of the Host header field. An intermediary that converts an HTTP/3 request to HTTP/1.1 **MUST** create a Host field if one is not present in a request by copying the value of the :authority pseudo-header field.
>
> - ":path":
>
>   Contains the path and query parts of the target URI (the "path-absolute" production and optionally a `?` character (ASCII 0x3f) followed by the "query" production; see Sections [3.3](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) and [3.4](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) of [[URI](https://www.rfc-editor.org/rfc/rfc9114.html#URI)].
>
>   This pseudo-header field **MUST NOT** be empty for "http" or "https" URIs; "http" or "https" URIs that do not contain a path component **MUST** include a value of `/` (ASCII 0x2f). An OPTIONS request that does not include a path component includes the value `*` (ASCII 0x2a) for the :path pseudo-header field; see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)].
>

为请求定义了以下伪首部字段：

- ":method":
  包含 HTTP 方法（[HTTP] 的第 9 节）

- ":scheme":
  包含目标 URI 的方案部分（[URI] 的第 3.1 节）。

  :scheme 伪首部不限于“http”和“https”格式的 URI。代理或网关可以转换非 HTTP 格式的请求，使 HTTP 能够与非 HTTP 服务进行交互。

  有关使用“https”以外的方案的指导，请参见第 3.1.2 节。

- ":authority":
  包含目标 URI 的授权部分（[URI] 的第 3.2 节）。权限**不得**包含方案“http”或“https”的 URI 的已弃用 userinfo 子部分。

  为确保 HTTP/1.1 请求行可以准确再现，当从具有特定方法形式的请求目标的 HTTP/1.1 请求转换时，**必须**省略此伪首部字段；参见 [HTTP] 的第 7.1 节。直接生成 HTTP/3 请求的客户端**应该**使用 :authority 伪首部字段而不是 Host 首部字段。如果请求中不存在主机字段，则将 HTTP/3 请求转换为 HTTP/1.1 的中介**必须**通过复制 :authority 伪首部字段的值来创建 Host 字段。

- ":path":
  包含目标 URI 的路径和查询部分（“绝对路径”的产生和可选的 ? 字符（ASCII 0x3f）后跟“查询”的产生；参见 [URI] 的第 3.3 和 3.4 节。

  对于“http”或“https”URI，此伪首部字段**不得**为空；不包含路径组件的“http”或“https”URI **必须**包含值 /（ASCII 0x2f）。不包含路径组件的 OPTIONS 请求包含 :path 伪标头字段的值 * (ASCII 0x2a)；参见 [HTTP] 的第 7.1 节。


> All HTTP/3 requests **MUST** include exactly one value for the :method, :scheme, and :path pseudo-header fields, unless the request is a CONNECT request; see [Section 4.4](https://www.rfc-editor.org/rfc/rfc9114.html#connect).

所有 HTTP/3 请求必须只包含一个 :method、:scheme 和 :path 伪首部字段的值，除非请求是 CONNECT 请求；见第 4.4 节。

> If the :scheme pseudo-header field identifies a scheme that has a mandatory authority component (including "http" and "https"), the request **MUST** contain either an :authority pseudo-header field or a Host header field. If these fields are present, they **MUST NOT** be empty. If both fields are present, they **MUST** contain the same value. If the scheme does not have a mandatory authority component and none is provided in the request target, the request **MUST NOT** contain the :authority pseudo-header or Host header fields.

如果 :scheme 伪标头字段标识了具有强制权限组件（包括“http”和“https”）的方案，则请求**必须**包含 :authority 伪首部字段或 Host 首部字段。如果这些字段存在，则它们**不得**为空。如果两个字段都存在，它们**必须**包含相同的值。如果该方案没有强制授权组件并且在请求目标中没有提供任何内容，则请求**不得**包含 :authority 伪标头或 Host 标头字段。

> An HTTP request that omits mandatory pseudo-header fields or contains invalid values for those pseudo-header fields is [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

省略强制性伪首部字段或包含这些伪首部字段的无效值的 HTTP 请求格式错误。

> HTTP/3 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line. HTTP/3 requests implicitly have a protocol version of "3.0".

HTTP/3 没有定义携带包含在 HTTP/1.1 请求行中的版本标识符的方法。 HTTP/3 请求隐含的协议版本为“3.0”。

### 4.3.2. Response Pseudo-Header Fields / 响应伪首部字段

> For responses, a single ":status" pseudo-header field is defined that carries the HTTP status code; see [Section 15](https://www.rfc-editor.org/rfc/rfc9110#section-15) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. This pseudo-header field **MUST** be included in all responses; otherwise, the response is [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed) (see [Section 4.1.2](https://www.rfc-editor.org/rfc/rfc9114.html#malformed)).
>
> HTTP/3 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line. HTTP/3 responses implicitly have a protocol version of "3.0".

对于响应，定义了一个带有 HTTP 状态代码的“:status”伪首部字段； 参见 [HTTP] 的第 15 节。 这个伪首部**必须**包含在所有响应中； 否则，响应格式错误（参见第 4.1.2 节）。

HTTP/3 没有定义携带包含在 HTTP/1.1 状态行中的版本或原因短语的方法。 HTTP/3 响应隐含的协议版本为“3.0”。

## 4.4. The CONNECT Method / CONNECT 方法

> The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target; see [Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]. It is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with "https" resources.

CONNECT 方法请求接收方建立一条到请求目标标识的目标源服务器的隧道；请参阅 [HTTP] 的第 9.3.6 节。它主要与 HTTP 代理一起使用，以与源服务器建立 TLS 会话，以便与“https”资源进行交互。

> In HTTP/1.x, CONNECT is used to convert an entire HTTP connection into a tunnel to a remote host. In HTTP/2 and HTTP/3, the CONNECT method is used to establish a tunnel over a single stream.

在 HTTP/1.x 中，CONNECT 用于将整个 HTTP 连接转换为到远程主机的隧道。在 HTTP/2 和 HTTP/3 中，CONNECT 方法用于在单个流上建立隧道。

> A CONNECT request **MUST** be constructed as follows:
>
> - The :method pseudo-header field is set to "CONNECT"
> - The :scheme and :path pseudo-header fields are omitted
> - The :authority pseudo-header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests; see [Section 7.1](https://www.rfc-editor.org/rfc/rfc9110#section-7.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]).

一个 CONNECT 请求**必须**构造如下： 

- :method 伪首部字段设置为“CONNECT” 
- :scheme 和 :path 伪首部字段被省略 
- :authority 伪首部字段包含要连接的主机和端口（相当于 CONNECT 请求的请求目标的权限形式；参见 [HTTP] 的第 7.1 节）。 

> The [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) remains open at the end of the request to carry the data to be transferred. A CONNECT request that does not conform to these restrictions is [malformed](https://www.rfc-editor.org/rfc/rfc9114.html#malformed).

请求流在请求结束时保持打开以携带要传输的数据。不符合这些限制的 CONNECT 请求格式不正确。

> A proxy that supports CONNECT establishes a TCP connection ([[RFC0793](https://www.rfc-editor.org/rfc/rfc9114.html#RFC0793)]) to the server identified in the :authority pseudo-header field. Once this connection is successfully established, the proxy sends a [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame containing a 2xx series status code to the client, as defined in [Section 15.3](https://www.rfc-editor.org/rfc/rfc9110#section-15.3) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)].

支持 CONNECT 的代理与 :authority 伪首部字段中标识的服务器建立 TCP 连接（[RFC0793]）。一旦成功建立此连接，代理就会向客户端发送一个包含 2xx 系列状态代码的 HEADERS 帧，如 [HTTP] 的第 15.3 节中所定义。

> All [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames on the stream correspond to data sent or received on the TCP connection. The payload of any [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is packaged into [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames by the proxy. Note that the size and number of TCP segments is not guaranteed to map predictably to the size and number of HTTP [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) or QUIC STREAM frames.

流上的所有 DATA 帧都对应于 TCP 连接上发送或接收的数据。客户端发送的任何 DATA 帧的有效载荷由代理传输到 TCP 服务器；从 TCP 服务器接收到的数据被代理打包成 DATA 帧。请注意，不能保证 TCP 段的大小和数量可预测地映射到 HTTP DATA 或 QUIC STREAM 帧的大小和数量。

> Once the CONNECT method has completed, only [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames are permitted to be sent on the stream. Extension frames **MAY** be used if specifically permitted by the definition of the extension. Receipt of any other known frame type **MUST** be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_UNEXPECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_UNEXPECTED).

一旦 CONNECT 方法完成，就只允许在流上发送 DATA 帧。如果扩展定义特别允许，**可以**使用扩展帧。任何其他已知帧类型的接收**必须**被视为 H3_FRAME_UNEXPECTED 类型的连接错误。

> The TCP connection can be closed by either peer. When the client ends the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) (that is, the receive stream at the proxy enters the "Data Recvd" state), the proxy will set the FIN bit on its connection to the TCP server. When the proxy receives a packet with the FIN bit set, it will close the send stream that it sends to the client. TCP connections that remain half closed in a single direction are not invalid, but are often handled poorly by servers, so clients **SHOULD NOT** close a stream for sending while they still expect to receive data from the target of the CONNECT.

TCP 连接可以由任一对等方关闭。当客户端结束请求流（即代理处的接收流进入“Data Recvd”状态）时，代理将在其与 TCP 服务器的连接上设置 FIN 位。当代理接收到一个设置了 FIN 位的数据包时，它将关闭它发送给客户端的发送流。在单个方向上保持半关闭的 TCP 连接并非无效，但服务器通常处理不当，因此客户端**不应**在仍期望从 CONNECT 目标接收数据时关闭用于发送的流。

> A TCP [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) is signaled by abruptly terminating the stream. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a [stream error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_CONNECT_ERROR](https://www.rfc-editor.org/rfc/rfc9114.html#H3_CONNECT_ERROR).

通过突然终止流来表示 TCP 连接错误。代理将 TCP 连接中的任何错误（包括接收设置了 RST 位的 TCP 段）视为 H3_CONNECT_ERROR 类型的流错误。

> Correspondingly, if a proxy detects an error with the stream or the QUIC connection, it **MUST** close the TCP connection. If the proxy detects that the client has reset the stream or aborted reading from the stream, it **MUST** close the TCP connection. If the stream is reset or reading is aborted by the client, a proxy **SHOULD** perform the same operation on the other direction in order to ensure that both directions of the stream are cancelled. In all these cases, if the underlying TCP implementation permits it, the proxy **SHOULD** send a TCP segment with the RST bit set.

相应地，如果代理检测到流或 QUIC 连接错误，它**必须**关闭 TCP 连接。如果代理检测到客户端已重置流或中止从流中读取，它**必须**关闭 TCP 连接。如果流被重置或读取被客户端中止，代理**应该**在另一个方向上执行相同的操作，以确保流的两个方向都被取消。在所有这些情况下，如果底层 TCP 实现允许，代理**应该**发送一个设置了 RST 位的 TCP 段。

> Since CONNECT creates a tunnel to an arbitrary server, proxies that support CONNECT **SHOULD** restrict its use to a set of known ports or a list of safe request targets; see [Section 9.3.6](https://www.rfc-editor.org/rfc/rfc9110#section-9.3.6) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)] for more details.

由于 CONNECT 创建了一个到任意服务器的隧道，支持 CONNECT 的代理**应该**将其使用限制在一组已知端口或安全请求目标列表；有关详细信息，请参阅 [HTTP] 的第 9.3.6 节。

## 4.5. HTTP Upgrade / HTTP 升级

> HTTP/3 does not support the HTTP Upgrade mechanism ([Section 7.8](https://www.rfc-editor.org/rfc/rfc9110#section-7.8) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]) or the 101 (Switching Protocols) informational status code ([Section 15.2.2](https://www.rfc-editor.org/rfc/rfc9110#section-15.2.2) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]).

HTTP/3 不支持 HTTP 升级机制（[HTTP] 的第 7.8 节）或 101（交换协议）信息状态代码（[HTTP] 的第 15.2.2 节）。

## 4.6. Server Push / 服务器推送

> Server push is an interaction mode that permits a server to push a request-response exchange to a client in anticipation of the client making the indicated request. This trades off network usage against a potential latency gain. HTTP/3 server push is similar to what is described in [Section 8.2](https://www.rfc-editor.org/rfc/rfc9113#section-8.2) of [[HTTP/2](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9113)], but it uses different mechanisms.

服务器推送是一种交互模式，它允许服务器将请求-响应交换推送到客户端，以等待客户端发出指示的请求。这权衡了网络使用与潜在的延迟增益。 HTTP/3 服务器推送与 [HTTP/2] 的 8.2 节中描述的类似，但它使用不同的机制。

> Each server push is assigned a unique push ID by the server. The push ID is used to refer to the push in various contexts throughout the lifetime of the HTTP/3 connection.

每个服务器推送都由服务器分配一个唯一的推送 ID。推送 ID 用于在 HTTP/3 连接的整个生命周期中指代各种上下文中的推送。

> The push ID space begins at zero and ends at a maximum value set by the [MAX_PUSH_ID](https://www.rfc-editor.org/rfc/rfc9114.html#frame-max-push-id) frame. In particular, a server is not able to push until after the client sends a [MAX_PUSH_ID](https://www.rfc-editor.org/rfc/rfc9114.html#frame-max-push-id) frame. A client sends [MAX_PUSH_ID](https://www.rfc-editor.org/rfc/rfc9114.html#frame-max-push-id) frames to control the number of pushes that a server can promise. A server **SHOULD** use push IDs sequentially, beginning from zero. A client **MUST** treat receipt of a [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_ID_ERROR](https://www.rfc-editor.org/rfc/rfc9114.html#H3_ID_ERROR) when no [MAX_PUSH_ID](https://www.rfc-editor.org/rfc/rfc9114.html#frame-max-push-id) frame has been sent or when the stream references a push ID that is greater than the maximum push ID.

推送 ID 空间从零开始，以 MAX_PUSH_ID 帧设置的最大值结束。特别的，在客户端发送 MAX_PUSH_ID 帧之前，服务器无法推送。客户端发送 MAX_PUSH_ID 帧来控制服务器可以承诺的推送次数。服务器应该按顺序使用推送 ID，从零开始。当没有发送 MAX_PUSH_ID 帧或当流引用大于最大推送 ID 的推送 ID 时，客户端必**须将**接收到推送流视为 H3_ID_ERROR 类型的连接错误。

> The push ID is used in one or more [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames that carry the control data and header fields of the request message. These frames are sent on the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) that generated the push. This allows the server push to be associated with a client request. When the same push ID is promised on multiple [request streams](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams), the decompressed request field sections **MUST** contain the same fields in the same order, and both the name and the value in each field **MUST** be identical.

推送 ID 用于一个或多个 PUSH_PROMISE 帧中，该帧携带请求消息的控制数据和首部字段。这些帧在生成推送的请求流上发送。这允许服务器推送与客户端请求相关联。当在多个请求流上承诺相同的推送 ID 时，解压后的请求字段部分**必须**包含相同顺序的相同字段，并且每个字段中的名称和值都**必须**相同。 

> The push ID is then included with the [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) that ultimately fulfills those promises. The [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) identifies the push ID of the promise that it fulfills, then contains a response to the promised request as described in [Section 4.1](https://www.rfc-editor.org/rfc/rfc9114.html#request-response).

然后推送 ID 包含在最终实现这些承诺的推送流中。推送流识别它履行的承诺的推送 ID，然后包含对承诺请求的响应，如第 4.1 节所述。

> Finally, the push ID can be used in [CANCEL_PUSH](https://www.rfc-editor.org/rfc/rfc9114.html#frame-cancel-push) frames; see [Section 7.2.3](https://www.rfc-editor.org/rfc/rfc9114.html#frame-cancel-push). Clients use this frame to indicate they do not wish to receive a promised resource. Servers use this frame to indicate they will not be fulfilling a previous promise.

最后，可以在 CANCEL_PUSH 帧中使用推送 ID；见第 7.2.3 节。客户使用此框架表示他们不希望收到承诺的资源。服务器使用这个框架来表明他们不会履行之前的承诺。

> Not all requests can be pushed. A server **MAY** push requests that have the following properties:
>
> - cacheable; see [Section 9.2.3](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.3) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]
> - safe; see [Section 9.2.1](https://www.rfc-editor.org/rfc/rfc9110#section-9.2.1) of [[HTTP](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9110)]
> - does not include request content or a trailer section

并非所有请求都可以推送。服务器**可以**推送具有以下属性的请求： 

- 可缓存的；请参阅 [HTTP] 的第 9.2.3 节 
- 安全的;请参阅 [HTTP] 的第 9.2.1 节 
- 不包括请求内容或尾部 

> The server **MUST** include a value in the :authority pseudo-header field for which the server is authoritative. If the client has not yet validated the connection for the origin indicated by the pushed request, it **MUST** perform the same verification process it would do before sending a request for that origin on the connection; see [Section 3.3](https://www.rfc-editor.org/rfc/rfc9114.html#connection-reuse). If this verification fails, the client **MUST NOT** consider the server authoritative for that origin.

服务器**必须**在 :authority 伪首部字段中包含一个服务器对其具有权威性的值。如果客户端尚未验证推送请求所指示的源的连接，它**必须**执行与在连接上发送该源的请求之前相同的验证过程；见第 3.3 节。如果此验证失败，则客户端**不得**认为服务器对该来源具有权威性。

> Clients **SHOULD** send a [CANCEL_PUSH](https://www.rfc-editor.org/rfc/rfc9114.html#frame-cancel-push) frame upon receipt of a [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame carrying a request that is not cacheable, is not known to be safe, that indicates the presence of request content, or for which it does not consider the server authoritative. Any corresponding responses **MUST NOT** be used or cached.

客户端**应该**在收到一个 PUSH_PROMISE 帧时发送一个 CANCEL_PUSH 帧，该帧携带的请求是不可缓存的，不知道是安全的，表示请求内容的存在，或者它不认为服务器具有权威性。**不得**使用或缓存任何相应的响应。

> Each pushed response is associated with one or more client requests. The push is associated with the [request stream](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams) on which the [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame was received. The same server push can be associated with additional client requests using a [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame with the same push ID on multiple [request streams](https://www.rfc-editor.org/rfc/rfc9114.html#request-streams). These associations do not affect the operation of the protocol, but they **MAY** be considered by user agents when deciding how to use pushed resources.

每个推送的响应都与一个或多个客户端请求相关联。推送与接收到 PUSH_PROMISE 帧的请求流相关联。在多个请求流上使用具有相同推送 ID 的 PUSH_PROMISE 帧可以将同一服务器推送与其他客户端请求相关联。这些关联不会影响协议的运行，但用户代理在决定如何使用推送资源时**可能**会考虑它们。

> Ordering of a [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame in relation to certain parts of the response is important. The server **SHOULD** send [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frames prior to sending [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) or [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frames that reference the promised responses. This reduces the chance that a client requests a resource that will be pushed by the server.

与响应的某些部分相关的 PUSH_PROMISE 帧的顺序很重要。服务器**应该**在发送引用承诺响应的 HEADERS 或 DATA 帧之前发送 PUSH_PROMISE 帧。这减少了客户端请求将由服务器推送的资源的机会。

> Due to reordering, [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) data can arrive before the corresponding [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame. When a client receives a new [push stream](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) with an as-yet-unknown push ID, both the associated client request and the pushed request header fields are unknown. The client can buffer the stream data in expectation of the matching [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise). The client can use stream flow control ([Section 4.1](https://www.rfc-editor.org/rfc/rfc9000#section-4.1) of [[QUIC-TRANSPORT](https://www.rfc-editor.org/rfc/rfc9114.html#QUIC-TRANSPORT)]) to limit the amount of data a server may commit to the pushed stream. Clients **SHOULD** abort reading and discard data already read from [push streams](https://www.rfc-editor.org/rfc/rfc9114.html#push-streams) if no corresponding [PUSH_PROMISE](https://www.rfc-editor.org/rfc/rfc9114.html#frame-push-promise) frame is processed in a reasonable amount of time.

由于重新排序，推流数据可以在相应的 PUSH_PROMISE 帧之前到达。当客户端接收到带有未知推送 ID 的新推送流时，关联的客户端请求和推送的请求标头字段都是未知的。客户端可以缓存流数据以期待匹配的 PUSH_PROMISE。客户端可以使用流的流量控制（[QUIC-TRANSPORT] 的第 4.1 节）来限制服务器可能提交给推送流的数据量。如果在合理的时间内没有处理相应的 PUSH_PROMISE 帧，客户端应该中止读取并丢弃已经从推送流中读取的数据。

> Push stream data can also arrive after a client has cancelled a push. In this case, the client can abort reading the stream with an error code of [H3_REQUEST_CANCELLED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_REQUEST_CANCELLED). This asks the server not to transfer additional data and indicates that it will be discarded upon receipt.

推送流数据也可以在客户端取消推送后到达。在这种情况下，客户端可以使用错误代码 H3_REQUEST_CANCELLED 中止读取流。这要求服务器不要传输额外的数据，并表明它将在收到时被丢弃。

> Pushed responses that are cacheable (see [Section 3](https://www.rfc-editor.org/rfc/rfc9111#section-3) of [[HTTP-CACHING](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9111)]) can be stored by the client, if it implements an HTTP cache. Pushed responses are considered successfully validated on the origin server (e.g., if the "no-cache" cache response directive is present; see [Section 5.2.2.4](https://www.rfc-editor.org/rfc/rfc9111#section-5.2.2.4) of [[HTTP-CACHING](https://www.rfc-editor.org/rfc/rfc9114.html#RFC9111)]) at the time the pushed response is received.

如果客户端实现了 HTTP 缓存，则可缓存的推送响应（参见 [HTTP-CACHING] 的第 3 节）可以被客户端存储。 在接收到推送响应时，推送响应被认为在源服务器上成功验证（例如，如果存在“no-cache”缓存响应指令；参见 [HTTP-CACHING] 的第 5.2.2.4 节）。

> Pushed responses that are not cacheable **MUST NOT** be stored by any HTTP cache. They **MAY** be made available to the application separately.

不可缓存的推送响应**不得**由任何 HTTP 缓存存储。它们**可以**单独提供给应用程序。